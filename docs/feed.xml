<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-04-12T14:24:35-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">RodWaRE</title><subtitle>Blog</subtitle><author><name>Rodo Gómez</name></author><entry><title type="html">x86 Architecture: Architecture 101</title><link href="http://localhost:4000/x86arch-part1-intro-101" rel="alternate" type="text/html" title="x86 Architecture: Architecture 101" /><published>2021-04-02T15:45:00-06:00</published><updated>2021-04-02T15:45:00-06:00</updated><id>http://localhost:4000/x86arch-part1-arch-101</id><content type="html" xml:base="http://localhost:4000/x86arch-part1-intro-101">&lt;p&gt;Welcome to this new series of posts, this time we’ll be talking about &lt;strong&gt;x86-64 computer architecture&lt;/strong&gt;, specifically, on the firsts posts, I’ll give a very very basic introduction to computer architecture, how it works, CPU, memory and more, then in future posts we’ll discuss the hardware support that Intel 64 and IA-32 architectures give to Operating Systems to achieve:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Memory Management.&lt;/li&gt;
  &lt;li&gt;Memory Addressing.&lt;/li&gt;
  &lt;li&gt;Memory Protection.&lt;/li&gt;
  &lt;li&gt;Separation and protection between Kernel-space and User-space.&lt;/li&gt;
  &lt;li&gt;Interrupts.&lt;/li&gt;
  &lt;li&gt;Hardware I/O.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Besides talking about hardware specific support, we’ll explore &lt;strong&gt;how the Linux Kernel uses those hardware features&lt;/strong&gt; from x86 processors through kernel debugging, analyzing kernel source code and implementing kernel modules that extract information to be analized.&lt;/p&gt;

&lt;p&gt;By the moment of writing this post, I’m not sure about how many parts will compose this series, so this post will be the first out of &lt;em&gt;n&lt;/em&gt; posts within this new series.&lt;/p&gt;

&lt;p&gt;This first post will be about an introduction to computer architecture, we’ll discuss the components that a computer system has and how they interact between each other (just a general, but complete, description). 
Notice that the content in this post will be just an introduction to all those concepts, even when I would try to give you a complete and general overview of the architecture of a computer system and how it works, I’m not pretending to touch every tiny detail about the subject.&lt;/p&gt;

&lt;p&gt;Any way, if you want to go deeper on the concepts discussed in this post, I’ll leave some useful references and links in the &lt;strong&gt;References&lt;/strong&gt; section.&lt;/p&gt;

&lt;p&gt;So, without further ado, let’s get started.!&lt;/p&gt;

&lt;h2 id=&quot;computer-architecture-101&quot;&gt;Computer Architecture 101.&lt;/h2&gt;

&lt;p&gt;A &lt;strong&gt;computer system&lt;/strong&gt; consists of different components and subsystems that work together creating a system able to compute instructions that solve specific tasks. In order to build this kind of system, there are different ways in which you can design it, define its components, its organization and ultimately how everything works within such system. That computer’s design is called the &lt;strong&gt;&lt;em&gt;Computer Architecture&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;One of the most well known and implemented computer architecture in today’s computer systems is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Von_Neumann_architecture&quot;&gt;&lt;strong&gt;&lt;em&gt;Von Neumann Architecture.&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are other computer architectures that are well known and actually implemented by different processors and real applications, such as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Harvard_architecture&quot;&gt;Hardvard Architecture&lt;/a&gt;. Von Neumann Architecture and Hardvard Architecture have many things in common, but they differ in how some componets interact between each other, how they store and retrieve information depending on the type of information (machine instructions against data) and so on. Any way, since Intel processors implement Von Neumann Architecture, the concepts and theory about computer architecture discussed in this series will relate to Von Neumann Architecture.&lt;/p&gt;

&lt;h2 id=&quot;system-organization&quot;&gt;System Organization.&lt;/h2&gt;

&lt;p&gt;Simplifying things, computer systems based on Von Neumann Architecture consist mainly in 3 well defined components:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU.&lt;/li&gt;
  &lt;li&gt;Memory (RAM).&lt;/li&gt;
  &lt;li&gt;I/O Devices.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And then, the CPU have another set of components within it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Control Unit (CU).&lt;/li&gt;
  &lt;li&gt;Aritmetic Logic Unit (ALU).&lt;/li&gt;
  &lt;li&gt;Registers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;assets/computer-arch-series/von-neumman-arch.png&quot; alt=&quot;Von Neumann Arch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There are some processors that implement other hardware features such as caches, or even more than one processor within a single chip.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Basic system functionality.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;One of the most important features that Von Neumann brought with this architecture is that &lt;strong&gt;CPU instructions and data from processes are stored in memory&lt;/strong&gt; when they are loaded to be executed, then, when a process is executing, &lt;strong&gt;the CPU retreives CPU instructions and data&lt;/strong&gt; as needed. This was not the case in the early’s days of computing, when only data could be stored in memory and hardware circuitry had to be modified for each program to be properly executed. Because of this, Von Neumann Architecture systems are also referred as &lt;strong&gt;stored-program computers.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;All computations occur inside the CPU, as mentioned before, it retrieves information (CPU instructions and/or data) from memory and stores information in memory as needed as well. The CPU instructions are retreived and executed one by one, data is stored or retreived as needed, and when the execution of the current instruction is finished, then the CPU fetches the next one and repeats the cycle (this is the normal workflow of execution if we don’t consider &lt;strong&gt;interrupts&lt;/strong&gt;, I’ll cover software and hardware interrupts in a future post).&lt;/p&gt;

&lt;p&gt;It might be the case that the current executing process requires access to a hardware device that is connected to the CPU, in that case, the CPU communicates with I/O devices either sending or fetching information to/from them.&lt;/p&gt;

&lt;p&gt;In this type of computer architecture, to the CPU, &lt;strong&gt;dealing with most I/O devices is practically the same as dealing with memory&lt;/strong&gt;. To the CPU, I/O devices and memory are just external components to which it can interact with by sending or fetching data to/from them. Any way, there are differences in the way CPUs exchange information between memory and I/O devices, and of course, we’ll talk about it :D.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/computer-arch-series/system-bus-book.png&quot; alt=&quot;System bus book&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Image from Art of Intel x86 Assembly book (see References section)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;All this components, I/O devices, memory and the CPU, need a way to exchange information between them and the way in which that comunication is implemented is called &lt;strong&gt;the System Bus&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-system-bus&quot;&gt;The System Bus.&lt;/h2&gt;

&lt;p&gt;In simple terms, &lt;strong&gt;the System Bus is just a set of electrical conexions that exists in the physical circuit&lt;/strong&gt; (mother board of the computer) and this bus interconnects all the components in the computer system. The System Bus is literally a &lt;strong&gt;set of wires that transport electrical signals&lt;/strong&gt; between computer components.&lt;/p&gt;

&lt;p&gt;The specific implementation of the System Bus depends totally on the characteristics of the processor that’s being used but the function of the bus is always the same, to transport electrical signals between components allowing communication between them.&lt;/p&gt;

&lt;p&gt;A typical x86 processor uses &lt;em&gt;standard TTL logic levels&lt;/em&gt; as voltage for the transmitted signals. A standard TTL logic level &lt;em&gt;zero&lt;/em&gt; is represented by a voltage in the range 0.0 - 0.8v, whereas a logic &lt;em&gt;one&lt;/em&gt; is represented by a voltage level in the range 2.4 - 5v.&lt;/p&gt;

&lt;p&gt;The System Bus can be divided in 3 different busses:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data Bus.&lt;/li&gt;
  &lt;li&gt;Address Bus.&lt;/li&gt;
  &lt;li&gt;Control Bus.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;assets/computer-arch-series/system-bus.png&quot; alt=&quot;System bus&quot; /&gt;&lt;/p&gt;

&lt;p&gt;These busses have their own porpuse, but remember, all of them have the same essential function, transport electrical signals between components, the meaning of this signals and what information do the busses carry is what defines the specific function of each bus in the system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Data Bus.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As it’s name suggests, &lt;strong&gt;the Data Bus is used to shuffle data between the computer system components&lt;/strong&gt;. Historically, the size (I mean, how many wires the bus has) has changed between different processors, having size values of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;8 bits.&lt;/li&gt;
  &lt;li&gt;16 bits.&lt;/li&gt;
  &lt;li&gt;32 bits.&lt;/li&gt;
  &lt;li&gt;64 bits.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As you might expect, the newer the processor the bigger the data bus size.&lt;/p&gt;

&lt;p&gt;Even though all busses have different sizes between processors (data bus, control bus and address bus), &lt;strong&gt;the Data Bus size has more impact on the performance of the system than the other ones.&lt;/strong&gt; Practically, a system with a 16 bit data bus is twice as fast as a system with an 8 bit data bus. And sure, having a 32 bit data bus means that the circuit has 32 physical wires, each wire is equivalent to a bit.&lt;/p&gt;

&lt;p&gt;That way, the CPU is capable of moving data to/from memory in chunks of the same size of the data bus &lt;strong&gt;per memory cycle&lt;/strong&gt; (by memory cycle, I mean the entire event of storing or fetching data and it’s totally different than CPU cycles, so don’t confuse them). In a system with an 8 bit data bus, it takes one memory cycle to fetch 8 bits of data, twice for 16 bits and so on.&lt;/p&gt;

&lt;p&gt;It’s important to notice that the size of the data bus &lt;strong&gt;does not limit the size of data types that a process (program) can use&lt;/strong&gt;. You can have 32 bit data types in a program that is running on a system with a data bus of 16 bits, this only means that it will take two memory cycles to fetch the entire 32 bit data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Have you heard someone saying “I have a 32-bit system” or “my laptop is a 64-bit computer”?&lt;/strong&gt; Well, it turns out that &lt;strong&gt;the size of the Data Bus determines what’s called the size of the processor.&lt;/strong&gt; That way, a system with an 8 bit data bus is called an 8 bit processor, same way, a 32 bit processor has a 32 bit data bus.&lt;/p&gt;

&lt;p&gt;Notice that the data bus is not only used to move data between the CPU and memory, &lt;strong&gt;it is used as well for moving data between I/O devices and the CPU&lt;/strong&gt;. In fact, some I/O devices can appear another section in the accesible memory (remember that to the CPU, most I/O devices are kind of the same as memory).&lt;/p&gt;

&lt;p&gt;The CPU needs a way to specify from where in memory or from where in an I/O device it wants to fecth data (or store data). The solution to this is provided by the address bus.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Address Bus.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The CPU uses the address bus to specify the &lt;strong&gt;location, AKA address, from where it wants to retrieve data&lt;/strong&gt; (and again, to where store it) either from memory or from an I/O device. So every time the CPU wants to access information in memory or in I/O devices, it just places the corresponding address in the Address Bus.&lt;/p&gt;

&lt;p&gt;Memory and I/O devices have internal circuitry as well, when the CPU requests information from a specific address, the circuitry from memory and I/O devices recognizes that they contain the address requested by the processor, if they have such address of course, and acts in response (storing or sending data). If they don’t recongnize the address, they just ignore it.&lt;/p&gt;

&lt;p&gt;The amount of wires that the Address Bus has &lt;strong&gt;determines the amount of physical addressable memory.&lt;/strong&gt; That way, if you have an address bus with just one wire, you’d be able to address only two unique addresses, 0 and 1.&lt;/p&gt;

&lt;p&gt;Firsts x86 processors had an address bus of 20 bits (wires) which allows them to address up to 1,048,576 different locations, which is the same as 1 MegaByte of addressable memory.&lt;/p&gt;

&lt;p&gt;Modern processors have a 32 bits address bus, which allows them to address up to 4,294,976,296, or 4GB of addressable memory. There exist hardware mechanisms that allow an expansion of addressable memory increasing the address bus from a 32 bit address bus to a 36 bit address bus, allowing the processor to address up to 64GB of memory, but we’ll discuss it in a future post :D.&lt;/p&gt;

&lt;p&gt;Notice that &lt;strong&gt;memory and I/O devices share the same address bus!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Something important is, &lt;strong&gt;the maximum amount of addressable memory is always the same as the address bus size, but the address bus size for I/O devices is always 16 bits long&lt;/strong&gt;, what happens is that when accessing memory, all the address bus is used to specify the location in memory, but when accessing I/O devices, only the 16 &lt;em&gt;least significat bits&lt;/em&gt; of the address bus are used. In consequence the processor is able to address up to 65,536 different I/O locations.&lt;/p&gt;

&lt;p&gt;If the CPU sees memory and I/O as the same thing, how does the CPU specify that the resquested address belongs to a memory location and not to a I/O device and vice versa? How does the CPU communicates that it wants to store some data at a specific address instead of fetching data from that same address?
To solve this issues, the control bus comes into the picture!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Control Bus.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is probably the bus that has more differences between different processors, in simple terms, the control bus is used by the CPU to send specific signals to the rest of the components that determines how it wants to communicates. For example, &lt;strong&gt;there are 2 dedicated wires in the control bus used to specify if the CPU wants to &lt;em&gt;read&lt;/em&gt; data from memory or it it wants to &lt;em&gt;write&lt;/em&gt; data to memory.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As I said, there are different designs of the control bus, but regardless those differences, there are some signals that are common between processors.&lt;/p&gt;

&lt;p&gt;There are signals in the control bus that are used to specify when the CPU wants to &lt;em&gt;read&lt;/em&gt; or &lt;em&gt;write&lt;/em&gt; data, as well as signals used to specify if the CPU wants to access memory or an I/O device.&lt;/p&gt;

&lt;p&gt;So when the CPU wants to read something from memory, it places the desired address in the address bus, and it places the respective values in the control bus specifying it wants to read instead of writing, and that it want such information from memory and not an I/O device, finally the circuitry from memory recognizes that the CPU is asking for some information from it at an specific location, if such address exists, memory places the data in the data bus and the CPU just reads it, and that’s how (in a general description) communication between CPU and memory occurs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/computer-arch-series/read-memory.png&quot; alt=&quot;System bus&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And in the other hand, the control bus places the respective signal on the control bus specifying it wants to write some data in memory.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/computer-arch-series/write-memory.png&quot; alt=&quot;System bus&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Images form Art of Intel x86 Assembly book&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When the CPU wants information from an I/O device, the process is mostly the same, with the only difference that the CPU places in the control bus a signal specifying that it wants such information from I/O instead of memory. In this scenario, circuitry in the I/O device recognize that the CPU requested information from it, and if it contains the requested address, it responds placing the information located at such address in the data bus. And remember, the address bus for I/O devices is always 16 bits, so the CPU places the requested address in the address bus, but using the &lt;em&gt;least significant bits&lt;/em&gt; in the address bus and the remaining bits are just ignored.&lt;/p&gt;

&lt;p&gt;NOTE: By the moment of writing this post I haven’t found that much information about the exact configuration of the control bus signals on different processors, because of that I’m not able to specify the name of the signals, the values and interpretation they have on real processors D:, any way as soon as I get more information I’ll update this post :D.&lt;/p&gt;

&lt;h2 id=&quot;lets-talk-about-memory&quot;&gt;Let’s talk about memory.&lt;/h2&gt;

&lt;p&gt;Just before the end of this post, let’s talk about memory.
x86 processors supports &lt;strong&gt;byte addressable memory&lt;/strong&gt;, which this means is that the smallest and more basic unit of memory that x86 processors are able to access is a single byte (a byte is equal to 8 bits).&lt;/p&gt;

&lt;p&gt;You can imagine memory as an array of cells, &lt;strong&gt;each cell can store 1 byte&lt;/strong&gt;, or in other words, each cell is composed of 8 bits, and the exact location of each cell within the array is what is known as the &lt;strong&gt;memory address&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/computer-arch-series/memory-ram.png&quot; alt=&quot;Memory Ram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Memory addresses will be always given in hexadecimal numbers, so it’s really important that you understand numerical systems and conversions.&lt;/p&gt;

&lt;p&gt;When dealing with memory values and addresses, you will notice that some places uses the terms &lt;em&gt;word, byte, double word&lt;/em&gt; and so on, so let’s explain it.&lt;/p&gt;

&lt;p&gt;The most basic unit of memory (I’m talking about unit of memory itself, not unit of addressable memory by the CPU) is a &lt;strong&gt;bit&lt;/strong&gt;, with it you can represent 2 values, 0 or 1, and those two values could mean whatever you want them to mean, black and white, on or off, up or down, or even 7541 and 500.&lt;/p&gt;

&lt;p&gt;Then, there are the &lt;strong&gt;nibbles&lt;/strong&gt;, a nibble is a collection of &lt;strong&gt;4 bits&lt;/strong&gt; and the bit that is at the most right side is called the &lt;em&gt;least significant bit (LSB)&lt;/em&gt; in contrast with the most left side bit, which is called &lt;em&gt;the most significant bit (MSB)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Then we have a &lt;strong&gt;byte&lt;/strong&gt;, a byte is composed of &lt;strong&gt;8 bits, or 2 nibbles&lt;/strong&gt;, the nibble that is at the right is called the &lt;em&gt;Low Order nibble&lt;/em&gt; and the other one is called the &lt;em&gt;High Order nibble&lt;/em&gt;, this because the LO nibble contains the LSB and the HO nibble contains the MSB.&lt;/p&gt;

&lt;p&gt;Then we have a &lt;strong&gt;word&lt;/strong&gt;, a word consists of &lt;strong&gt;16 bits, or 2 bytes, or 4 nibbles.&lt;/strong&gt; It also has its LO nibble and HO nibble plus its HO byte and its LO byte.&lt;/p&gt;

&lt;p&gt;Then there is the &lt;strong&gt;double word&lt;/strong&gt;, a double word contains &lt;strong&gt;32 bits, or 4 bytes, or 8 nibbles&lt;/strong&gt;, and it has its LO and HO nibbles, bytes and words.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;assets/computer-arch-series/memory-units.jpg&quot; alt=&quot;Memory Ram&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This terms apply when you are talking about memory values, sizes of data types and other cases, for instance, when reading assembly, you might see an instrucction saying something like:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;no&quot;&gt;MOV&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;DWORD&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;PTR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ebx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;That &lt;em&gt;dword&lt;/em&gt; is telling that this assembly instrucction requires to access a value in memory that is a double word value, or a 4 bytes value.&lt;/p&gt;

&lt;p&gt;Well, this is already a huge post, it might be kind of boring to learn this things, I tried to be as brief as possible but complete and concrete at the same time.&lt;/p&gt;

&lt;p&gt;In the next post, (I’ll try to bring it soon xD), I’ll dive deep on the CPU, we’ll talk about the internals of the CPU, how they work, instruction set, registers and more, so I hope you find this post useful and informative and I encourage you to dive deeper in the subject if you are interested in.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Von_Neumann_architecture&quot;&gt;Von Neumann Architecture.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Harvard_architecture&quot;&gt;Hardvard Architecture.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/System_bus&quot;&gt;System Bus.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://archive.org/details/ArtOfIntelX86Assembly/page/n67/mode/2up&quot;&gt;The Art Of Intel x86 Assembly.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Rodo Gómez</name></author><summary type="html">Welcome to this new series of posts, this time we’ll be talking about x86-64 computer architecture, specifically, on the firsts posts, I’ll give a very very basic introduction to computer architecture, how it works, CPU, memory and more, then in future posts we’ll discuss the hardware support that Intel 64 and IA-32 architectures give to Operating Systems to achieve: Memory Management. Memory Addressing. Memory Protection. Separation and protection between Kernel-space and User-space. Interrupts. Hardware I/O.</summary></entry><entry><title type="html">Radare2: Basic workflow and usage - Part 2</title><link href="http://localhost:4000/radare2-basic-workflow-and-usage-part2" rel="alternate" type="text/html" title="Radare2: Basic workflow and usage - Part 2" /><published>2021-03-08T15:45:00-06:00</published><updated>2021-03-08T15:45:00-06:00</updated><id>http://localhost:4000/radare2-basic-wf-p2</id><content type="html" xml:base="http://localhost:4000/radare2-basic-workflow-and-usage-part2">&lt;p&gt;This is the second post out of two that describes the usage of Radare2 to perform basic tasks that relate to binary analysis. In the &lt;a href=&quot;https://rodogomez.github.io/radare2-basic-workflow-and-usage&quot;&gt;previous post&lt;/a&gt; a brief introduction to r2 was given, as well as a basic workflow working on command mode within r2.&lt;/p&gt;

&lt;p&gt;In this post, we’ll explore how to perform a basic analysis, operations and exploration of a binary working on &lt;strong&gt;Visual Mode&lt;/strong&gt; within r2.&lt;/p&gt;

&lt;h2 id=&quot;lets-recap-r2-modes-of-operation&quot;&gt;Let’s recap: r2 modes of operation.&lt;/h2&gt;

&lt;p&gt;As mentioned in the previous post, Radare2 has two modes of operation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Command Mode.&lt;/li&gt;
  &lt;li&gt;Visual Mode.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Command mode is the default mode, here, &lt;strong&gt;all r2 commands are available&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Visual mode provides a set of different commands and this mode outputs the information in a graphical way, same that is actually an interactive interface.&lt;/p&gt;

&lt;p&gt;One of the most important things you have to remember is that there are commands that perform the same action in both modes, but there are commands that, even when they look the same, perform a total different thing between modes.&lt;/p&gt;

&lt;p&gt;Finally, remember that, when in doubt, you can always use the &lt;strong&gt;&lt;em&gt;-? command-&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;before-we-jump-into-it&quot;&gt;Before we jump into it:&lt;/h2&gt;

&lt;p&gt;For this post, we’ll be using the same C program we used in the part 1:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xdefea7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; In this series of posts we will be working with x86 binaries under the Linux OS so, the code above was compiled with the following command:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gcc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Where &lt;em&gt;-m32&lt;/em&gt; is the compilation flag used to specify that we want gcc to compile our code for x86 architecture.&lt;/p&gt;

&lt;p&gt;So we have now an x86 binary ready to be analyzed with r2.&lt;/p&gt;

&lt;h2 id=&quot;opening-our-binary&quot;&gt;Opening our binary.&lt;/h2&gt;

&lt;p&gt;Let’s begin by opening our binary and run r2 analysis at once:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Remember that the fuse -A makes r2 to run an analysis of the binary, creating flags and gathering useful information about the binary.&lt;/p&gt;

&lt;p&gt;We should get the following result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/ss1.png&quot; alt=&quot;r2 -A ./post-sample&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;working-in-visual-mode&quot;&gt;Working in Visual Mode.&lt;/h2&gt;

&lt;p&gt;Visual mode provides, as its name suggests, a more graphical way of displaying information. In some way, visual mode provides a more user-friendly interface to work with when analyzing binaries.&lt;/p&gt;

&lt;p&gt;Something important you have to remember is that in visual mode not all the r2 commands are available, and there are commands that do a different thing in visual mode compared with command mode.&lt;/p&gt;

&lt;p&gt;This mode does not provide only one interface to the user, instead, visual mode consists of a set of &lt;strong&gt;&lt;em&gt;print modes&lt;/em&gt;&lt;/strong&gt;, also referred as &lt;strong&gt;&lt;em&gt;panels&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Something that is a little bit confusing at the beginning, and that is important that you understand, is that such print modes share some commands (those commands do the same regardless the print mode), but there are other commands that does not do the same action and even, there are commands that are present in some print modes but aren’t in others.&lt;/p&gt;

&lt;p&gt;You can think of it as if each print mode was actually a kind of &lt;em&gt;sub-mode&lt;/em&gt; within visual mode.&lt;/p&gt;

&lt;p&gt;The different print modes available in visual mode are:&lt;/p&gt;

&lt;p&gt;↻ Hexdump panel → Disassembly panel → Debugger panel → Hexadecimal words dump panel → Hex-less hexdump panel → Op analysis color map panel → Annotated hexdump panel ↻&lt;/p&gt;

&lt;p&gt;The arrows represent the order of switching between print modes.&lt;/p&gt;

&lt;p&gt;There is a special print mode, full of different functionalities and options, and it’s almost like if it was actually a third mode in r2, called &lt;strong&gt;&lt;em&gt;Panels view&lt;/em&gt;&lt;/strong&gt;, (which is the print mode that I personally use the most) but officially it is another print mode within visual mode, we’ll explore this special print mode last.&lt;/p&gt;

&lt;p&gt;You can switch between print modes, but before explaining that, let’s switch to Visual mode first.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Switching to visual mode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At this point, we are currently in command mode. In order to change to visual mode we can use the &lt;strong&gt;&lt;em&gt;-V command-&lt;/em&gt;&lt;/strong&gt; (note that is uppercase):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x08049050&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;V&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img1-Visual-mode-hex-dump.png&quot; alt=&quot;Visual mode hex dump view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now we are in visual mode. The default print mode that you see once you enter in visual mode is an &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hex_dump&quot;&gt;hex dump&lt;/a&gt; view of the current seek&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;You can switch to other print modes using either the &lt;strong&gt;&lt;em&gt;-p command-&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;-P command-&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;Disassembly panel:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img2-Visual-mode-disassembly-view.png&quot; alt=&quot;Visual mode disassembly view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Color map panel&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img3-color-map-panel.png&quot; alt=&quot;Color map panel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;By now, let’s explore our workflow within the disassembly panel.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Exploring the binary&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At this point, our current seek is the very beginning of our binary code, we can move around and explore the disassembled code using the &lt;em&gt;arrow keys or h, j, k, and l keys&lt;/em&gt;, same as the ones you use in the Vim text editor.&lt;/p&gt;

&lt;p&gt;Moving using such keys allows you to navigate the disassembled code but only one line at a time.&lt;/p&gt;

&lt;p&gt;You can go directly to specific locations, like a specific function or a specific part of the binary if you know its location within the binary, by using the flag of such function or binary location using the &lt;strong&gt;&lt;em&gt;_ command&lt;/em&gt;&lt;/strong&gt;. Let’s supose you want to go to the main function, just type _ and a list of r2 flags will be displayed:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img5-using_command-main.png&quot; alt=&quot;Using _ command&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Then just type &lt;em&gt;main&lt;/em&gt; and press ENTER.&lt;/p&gt;

&lt;p&gt;Now our current seek is the location of main:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img6-using_command-main2.png&quot; alt=&quot;Using _ command main2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This way, the _ command is useful to search for specific functions/locations within our binary.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The view management&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;View management is a functionality that &lt;strong&gt;is only available if you are NOT in Panels view&lt;/strong&gt; (but it’s available in all the other print modes).&lt;/p&gt;

&lt;p&gt;The view management provides a set of options and functionalities that can be applied to the functions of our binary.&lt;/p&gt;

&lt;p&gt;This functionality is accessed using the &lt;strong&gt;&lt;em&gt;-v command-&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img7-View-management.png&quot; alt=&quot;View management&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, a list of all the functions of our binary is displayed and a preview of the disassembled code of the selected function is showed as well.&lt;/p&gt;

&lt;p&gt;Using the &lt;em&gt;up&lt;/em&gt; and &lt;em&gt;down&lt;/em&gt; arrow keys, or &lt;em&gt;j&lt;/em&gt; and &lt;em&gt;k&lt;/em&gt; you can move between functions (see how an * symbol works as a cursor when moving around between functions in the list).&lt;/p&gt;

&lt;p&gt;Using the &lt;em&gt;right&lt;/em&gt; arrow key, or &lt;em&gt;l&lt;/em&gt; key, specific options (that applies to the current selected function) are displayed that relates to actions like add, rename, type and so on.&lt;/p&gt;

&lt;p&gt;For a simple binary analysis, the options that I found useful the most are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Rename a function.&lt;/li&gt;
  &lt;li&gt;The &lt;em&gt;calls&lt;/em&gt; option.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In order to ilustrate this functionalities, let’s rename our functions &lt;em&gt;sum&lt;/em&gt; and &lt;em&gt;mul&lt;/em&gt;. Remember that r2 found them when it ran the analysis and assigned them a flag. That way our functions are referenced by the flags &lt;em&gt;sym.sum&lt;/em&gt; and &lt;em&gt;sym.mul&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If we want to rename &lt;em&gt;sym.sum&lt;/em&gt; function, we move the cursor selecting it, and press &lt;strong&gt;&lt;em&gt;r&lt;/em&gt;&lt;/strong&gt;, after that we’ll be asked to write the new name:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img8-View-management-renaming-a-function.png&quot; alt=&quot;View management renaming a function&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s rename it as &lt;em&gt;sum&lt;/em&gt; and then press ENTER.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img9-Renaming-a-function-new-name.png&quot; alt=&quot;Renaming a function new name&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And the same applies to &lt;em&gt;sym.mul&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img10-Renaming-a-function-new-name2.png&quot; alt=&quot;Renaming a function new name2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In the other hand, the &lt;em&gt;calls&lt;/em&gt; option provides very useful information about the selected function, you can use this function just by typing &lt;strong&gt;&lt;em&gt;c&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img11-calls-functionality.png&quot; alt=&quot;calls functionality&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Some of the most useful information is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Call-convention: Tells us the calling convection that the code is using, this is important when reversing a binary.&lt;/li&gt;
  &lt;li&gt;locals: Tells us how many local variables are in the function (NOTE: the number of local variables may be different than the ones that were used in the source code, this is because the generated assembly code from the compiler may create more or less local variables depending on factors like optimizations at compile time.)&lt;/li&gt;
  &lt;li&gt;args: Tells us how many arguments there are in the function signature.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once you are done with the view management, you can exit from there by pressing &lt;strong&gt;&lt;em&gt;q&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;r2 commands within visual mode&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As said before, when you are in visual mode, not all the r2 commands are available, at least not directly. But such limitation is not that real. There is a way to &lt;strong&gt;execute all the commands that are available in command mode being in visual mode&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;When in visual mode, &lt;strong&gt;in any of the print modes&lt;/strong&gt;, you can get an “r2 terminal” to execute command mode commands by pressing &lt;strong&gt;&lt;em&gt;:&lt;/em&gt;&lt;/strong&gt; (semicolon)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img12-r2-commands-from-visual-mode.png&quot; alt=&quot;r2 commands from visual mode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, a promt is displayed. Here you can type and execute any of the commands that are present in command mode.&lt;/p&gt;

&lt;p&gt;This is really useful because, as long as you use Radare2, you’ll notice that you need to hex dump an specific location in memory, or print the contents of some location stored in a register and so on.&lt;/p&gt;

&lt;p&gt;When you start running commands in this promt, you may notice that the interface suffer a scrolling-up and you lose your print mode, &lt;strong&gt;don’t worry.!&lt;/strong&gt;, once you are done with your r2 commands, just press ENTER (without any command on the promt) and the print mode is restored as it was before switching to the promt.&lt;/p&gt;

&lt;p&gt;At this point, you should be able to navigate the disassembled code of any binary, rename functions, gather information, and explore more options in visual mode. But that’s not the end of this post, let’s now explore my favorite print mode, let’s explore &lt;strong&gt;Panels view&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;panels-view&quot;&gt;Panels view&lt;/h2&gt;

&lt;p&gt;Panels view provides an interface with splitted windows, each window is called a panel, and each of those panels can show different print modes or different r2 command’s output at the same time.&lt;/p&gt;

&lt;p&gt;That way, you can have a main panel that shows the disassembled code, another one to see the registers, another one to display the stack and so on.&lt;/p&gt;

&lt;p&gt;There are basically 2 ways to switch to panels view, depending on your current r2 mode:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Switching from visual mode to panels view&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To switch to panels view when you are currently in any print mode, within visual mode of course, just use the &lt;strong&gt;&lt;em&gt;-! command-&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img13-panels-view-1.png&quot; alt=&quot;panels view 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Switching from command mode to panels view&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To switch to panels view when you are currently in command mode, just use the &lt;strong&gt;&lt;em&gt;-v command-&lt;/em&gt;&lt;/strong&gt;(Note the lower case).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img13-panels-view-1.png&quot; alt=&quot;panels view 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;That way, if you are in command mode, using the &lt;strong&gt;&lt;em&gt;-v command-&lt;/em&gt;&lt;/strong&gt; you switch to &lt;strong&gt;panels view&lt;/strong&gt;, whereas using the &lt;strong&gt;&lt;em&gt;-V command-&lt;/em&gt;&lt;/strong&gt; change to &lt;strong&gt;visual mode&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Working in Panels view&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Panels view shares some functionalities with all the other print modes, but one that &lt;strong&gt;is not present is view management&lt;/strong&gt;, that way if you need something from view management you’ll need to switch to any other print mode.&lt;/p&gt;

&lt;p&gt;If you need to execute r2 commands, you can do it the same way as in any other print mode, by using the &lt;strong&gt;&lt;em&gt;-: command-&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img14-r2-commands-panel-view.png&quot; alt=&quot;r2 commands panel view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When I first ever launched this view, the default interface displayed 3 different panels, the bigger one showed the disassembled code, and the other ones showed an hex dum of the stack and the registers.&lt;/p&gt;

&lt;p&gt;Being honest, at this point I’m not sure if those are the default panels, but don’t worry, we’ll explore how to customize them.&lt;/p&gt;

&lt;p&gt;You can move between panels using the &lt;strong&gt;TAB key&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;As you can see, there are some options at the top of the window, you can access such options using the &lt;strong&gt;&lt;em&gt;-m command-&lt;/em&gt;&lt;/strong&gt;. You can explore the options available moving with the &lt;strong&gt;&lt;em&gt;arrow keys&lt;/em&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;em&gt;h, j, k and l&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img15-m-command-windows.png&quot; alt=&quot;m command windows&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If you want to search and go to an specific function in the disassembled code, you can do it the same way as in other print mode, using the &lt;strong&gt;&lt;em&gt;-_ command-&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Customizing the panels&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Let’s customize the two smaller panels. One way to achieve this is by moving to the desired panel and press the &lt;strong&gt;DEL key&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img16-customize-panel-1.png&quot; alt=&quot;customize panel 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A menu is displayed with multiple predefined options, you can choose from them and just press ENTER to make the selection.&lt;/p&gt;

&lt;p&gt;All this predefined views use an specific fixed r2 command, same that is visible at the top of each panel, but this is not the only way to customize the panels.&lt;/p&gt;

&lt;p&gt;You can provide to any panel your &lt;strong&gt;own custom r2 command&lt;/strong&gt; by using the &lt;strong&gt;&lt;em&gt;-e command-&lt;/em&gt;&lt;/strong&gt;, just move to the desired panel and use the command:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img17-customize-panel-2.png&quot; alt=&quot;customize panel 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At the top of the window, a promt will be displayed asking you to write your r2 command, that way, whatever the output of that command is, it will be displayed in the selected panel.&lt;/p&gt;

&lt;p&gt;I personally use those two panels to display the stack and the registers, respectively.&lt;/p&gt;

&lt;p&gt;The command I use to display the stack is:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;pxW&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@esp&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;em&gt;px&lt;/em&gt; belongs to the &lt;em&gt;print hexadecimal&lt;/em&gt; commands. &lt;em&gt;W&lt;/em&gt; specifies the size of the hex dump and stands for &lt;em&gt;word&lt;/em&gt; size. Notice that in radare2 a word is 32 bits. And &lt;em&gt;W&lt;/em&gt; is uppercase, which specifies that the output will be displayed one word per line.&lt;/p&gt;

&lt;p&gt;And for the registers I just use the predefined one, using the DEL key.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img18-custom-panels.png&quot; alt=&quot;custom panels&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;bonus-graph-view&quot;&gt;Bonus: Graph view&lt;/h2&gt;

&lt;p&gt;Graph view displays the disassembled code showing the branches (if any) and a call graph view as well.&lt;/p&gt;

&lt;p&gt;When in visual mode, &lt;strong&gt;in any print mode&lt;/strong&gt;, you can go to graph view using the &lt;strong&gt;SPACE key&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img19-Graph-view.png&quot; alt=&quot;Graph view&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/img20-Graph-view2.png&quot; alt=&quot;Graph view2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The displayed disassembled code depends on the current seek, if you are located at main in the binary, then the disassembled code will be from main.&lt;/p&gt;

&lt;p&gt;You can move around the graph view using the &lt;strong&gt;&lt;em&gt;arrow keys&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;h, j, k and l keys&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This view helps you see in a more ilustrative interface the branches created by &lt;em&gt;if&lt;/em&gt; statements, &lt;em&gt;switch cases&lt;/em&gt; and other &lt;em&gt;conditional&lt;/em&gt; and &lt;em&gt;non-conditional&lt;/em&gt; jumps in code.&lt;/p&gt;

&lt;h2 id=&quot;getting-help&quot;&gt;Getting help&lt;/h2&gt;

&lt;p&gt;Regardless the current mode you are in, you can use the &lt;strong&gt;&lt;em&gt;-? command&lt;/em&gt;&lt;/strong&gt; to get help.&lt;/p&gt;

&lt;h2 id=&quot;conclusions&quot;&gt;Conclusions&lt;/h2&gt;

&lt;p&gt;Now you should be able to perform a basic binary analysis using both command mode and visual mode. From here, you can dedice which mode, or which print mode, is better for you.&lt;/p&gt;

&lt;p&gt;Notice that knowing how to use tools for binary analysis, such as Radare2, is just useful if you have previous knowledge about concepts like assembly, computer architecture and even programming. In future posts, I’ll be exploring some stuff about those concepts that migth be helpful for everyone interested in this areas.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://radare.gitbooks.io/radare2book/content/&quot;&gt;Radare2 Official Book&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Rodo Gómez</name></author><summary type="html">This is the second post out of two that describes the usage of Radare2 to perform basic tasks that relate to binary analysis. In the previous post a brief introduction to r2 was given, as well as a basic workflow working on command mode within r2.</summary></entry><entry><title type="html">Radare2: Basic workflow and usage - Part 1</title><link href="http://localhost:4000/radare2-basic-workflow-and-usage" rel="alternate" type="text/html" title="Radare2: Basic workflow and usage - Part 1" /><published>2021-02-22T15:45:00-06:00</published><updated>2021-02-22T15:45:00-06:00</updated><id>http://localhost:4000/radare2-basic-wf-p1</id><content type="html" xml:base="http://localhost:4000/radare2-basic-workflow-and-usage">&lt;p&gt;This is the first post out of two that describes the usage of Radare2 to perform basic tasks that relate to binary analysis. That way, instead of explaining what a bunch of Radare commands do, this post goes through a basic workflow from opening a binary file, gather basic information about it, dissasemble it, explaining and working with the different modes that Radare2 offers and explore the disassembled binary.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Debugging a binary file deserves its own post so it will be covered in a future post.&lt;/p&gt;

&lt;h2 id=&quot;lets-begin-whats-radare2&quot;&gt;Let’s begin: What’s Radare2?&lt;/h2&gt;

&lt;p&gt;Radare2, also known as &lt;strong&gt;r2&lt;/strong&gt;, is the integration of a set of Unix-like, &lt;strong&gt;open source&lt;/strong&gt;, tools to perform binary analysis from different standpoints of view. As any &lt;em&gt;Unix-like&lt;/em&gt; application, r2 provides a &lt;strong&gt;command-line inteface&lt;/strong&gt; to interact with.&lt;/p&gt;

&lt;p&gt;There exist GUIs such as &lt;a href=&quot;https://github.com/rizinorg/cutter&quot;&gt;Cutter&lt;/a&gt;, which is powered by &lt;a href=&quot;https://github.com/rizinorg/rizin&quot;&gt;Rizin&lt;/a&gt; (a fork of r2 focused on usability).&lt;/p&gt;

&lt;p&gt;Because of its capabilities, r2 can be seen as:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A reverse engineering framework.&lt;/li&gt;
  &lt;li&gt;A forensics tool for binaries.&lt;/li&gt;
  &lt;li&gt;A debugging tool.&lt;/li&gt;
  &lt;li&gt;An exploit development framework.&lt;/li&gt;
  &lt;li&gt;and much more…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can get r2 from its &lt;a href=&quot;https://github.com/radareorg/radare2&quot;&gt;Official GitHub repo&lt;/a&gt;. Instructions about how to clone it, install it and set it up can be found there.&lt;/p&gt;

&lt;p&gt;If you wish to read a more extended documentation about r2, you can go through its &lt;a href=&quot;https://book.rada.re/&quot;&gt;Official book&lt;/a&gt; as well.&lt;/p&gt;

&lt;h2 id=&quot;before-we-jump-into-it&quot;&gt;Before we jump into it:&lt;/h2&gt;

&lt;p&gt;For this series of posts, we are going to use the following simple C program:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mul&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xdefea7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; In this series of posts we will be working with x86 binaries under the Linux OS so, the code above was compiled with the following command:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gcc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m32&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;o&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Where &lt;em&gt;-m32&lt;/em&gt; is the compilation flag used to specify that we want gcc to compile our code for x86 architecture.&lt;/p&gt;

&lt;p&gt;So we have now an x86 binary ready to be analyzed with r2.&lt;/p&gt;

&lt;h2 id=&quot;opening-a-binary-with-radare2&quot;&gt;Opening a binary with Radare2&lt;/h2&gt;

&lt;p&gt;As mentioned before, r2 is a set of &lt;em&gt;Unix-like&lt;/em&gt; tools, so from this point everything is going to be achieved with commands.&lt;/p&gt;

&lt;p&gt;The simpliest way to open a binary with r2 is by just providing to r2 command the name of our binary file without any other fuse (aka flag):&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;radare2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;By doing it this way, r2 is just going to open the binary file without performing any sort of analysis to it (more on this below).&lt;/p&gt;

&lt;p&gt;To see the different fuses that r2 accepts when launching it, you can use the command:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The fuse that we are going to be using the most when working with r2 is -A, that way the command to open our file is:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sample&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;When reading the help for the commands available, we see that for the fuse -A the help says that &lt;em&gt;“run aaa command to analyze all referenced code”&lt;/em&gt;. This means that first it opens the binary with radare2 and then it runs the r2 command &lt;em&gt;aaa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;One of the outputs from running &lt;em&gt;aaa&lt;/em&gt; command is the creation of flags (as radare2 call them). With aaa command, r2 goes through the provided binary and for everything that founds to be interesting creates a flag to reference it.&lt;/p&gt;

&lt;p&gt;For example, it creates flags for functions, variables, sections and so on. That’s the way r2 makes a ‘recognition’ of the binary and its properties.&lt;/p&gt;

&lt;p&gt;It also gathers useful information about the binary in question, such as metadata associated with it, compilation information such as compilation flags used, compiler version, timestamps, binary size, sections, the system used for the creation of the binary, exploitation mitigations status, permissions and more.&lt;/p&gt;

&lt;p&gt;Notice that you can get the same result by opening the file without the -A flag and then run the &lt;em&gt;aaa&lt;/em&gt; command manually once you are in r2.&lt;/p&gt;

&lt;p&gt;Once we open our file, we get the following result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/ss1.png&quot; alt=&quot;r2 -A ./post-sample&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The output that is displayed is the result of the option -A.&lt;/p&gt;

&lt;h2 id=&quot;radare2-modes-of-operation&quot;&gt;Radare2 modes of operation&lt;/h2&gt;

&lt;p&gt;In general terms, we could say that Radare2 has &lt;strong&gt;2 modes&lt;/strong&gt; of operation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Command mode&lt;/li&gt;
  &lt;li&gt;Visual mode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Command mode:&lt;/strong&gt; This is the default mode within r2. When in this mode, &lt;strong&gt;all&lt;/strong&gt; r2 commands are available.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Visual mode:&lt;/strong&gt; This mode provides a set of different capabilities in which you can see and interact with the binary and its information. As its name suggests, the information is outputed in a more visual and graphical way.&lt;/p&gt;

&lt;p&gt;There are several differences of how each mode works, commands, options and so on, but &lt;strong&gt;the most important difference&lt;/strong&gt; that you have to get in mind is that &lt;strong&gt;the available commands between modes differ in the total number of them and what they do.&lt;/strong&gt; In command mode, all r2 commands are available whereas in visual mode, there are less commands available but, &lt;strong&gt;there are commands that perform a different thing between modes.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In other words, in visual mode you have a set of commands that are less than the ones available in command mode, some commands do the same in both modes, but there are commands that in visual mode do a total different thing.&lt;/p&gt;

&lt;p&gt;Understanding that and having it in mind will save you several mistakes and time :D&lt;/p&gt;

&lt;p&gt;We are going to start with command mode and then we’ll move to visual mode (which is the mode that I actually use the most).&lt;/p&gt;

&lt;h2 id=&quot;working-in-command-mode&quot;&gt;Working in command mode&lt;/h2&gt;

&lt;p&gt;Once we open our binary, the default mode is the command mode. You can see that an hex number appears in the r2 promt, that hex number (which varies between platforms such as Windows, Linux, etc) is our current location (address location) within the binary, also known as our current &lt;em&gt;seek&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Displaying information&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;As our binary has been already analyzed, the &lt;strong&gt;&lt;em&gt;-i command-&lt;/em&gt;&lt;/strong&gt; displays a bunch of information collected during r2 analysis.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x08049050&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can clear the screen with the command, well, &lt;strong&gt;&lt;em&gt;-clear-&lt;/em&gt;&lt;/strong&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x08049050&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;List functions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;One very useful command is the &lt;strong&gt;&lt;em&gt;-afl command-&lt;/em&gt;&lt;/strong&gt;. It’s used to list all functions that r2 found in the binary:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/afl-command.png&quot; alt=&quot;afl command&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can see the functions of our program referenced as &lt;em&gt;sym.sum&lt;/em&gt;, &lt;em&gt;sym.mul&lt;/em&gt; and &lt;em&gt;main&lt;/em&gt;. Those are the flags mentioned before, it’s a kind of tag created by r2 and used to reference useful properties found in the binary.&lt;/p&gt;

&lt;p&gt;This information wouldn’t be available if we do not perform the analysis either by opening the file with the -A option or by running the &lt;em&gt;aaa&lt;/em&gt; command in radare2.&lt;/p&gt;

&lt;p&gt;Another nice way to list all the functions with a bit more of information presented like a table is by using the &lt;strong&gt;&lt;em&gt;-afll command.-&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/afll-command.png&quot; alt=&quot;afll command&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Printing the disassembled binary&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;One of the main functionalities used in r2 is the disassembler. There are different ways to display the disassembled code in r2, the simpliest one is just using the &lt;strong&gt;&lt;em&gt;-pd command-&lt;/em&gt;&lt;/strong&gt;, which stands for &lt;em&gt;print disassembly&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/pd-command.png&quot; alt=&quot;pd command&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;pd&lt;/em&gt; command prints the disassembled code of the &lt;strong&gt;current&lt;/strong&gt; location. You can see that it displays just a part of all the disassembly code, that is because of the block size.&lt;/p&gt;

&lt;p&gt;The default value of the block size is 0x100 and can be set with the &lt;strong&gt;&lt;em&gt;-b command-&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x08049050&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;You can print the disassembly code of all the content of a function regardless if it fits or not in the block size. To print a disassembled function you can use the command:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x08049050&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pdf&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Where &lt;em&gt;function-flag&lt;/em&gt; is the flag that r2 assign to our function (the ones we saw when listing the functions previously). Notice that &lt;em&gt;pdf&lt;/em&gt; stands for &lt;em&gt;print disassembled function&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;That way, in order to print the disassembled code of &lt;em&gt;main&lt;/em&gt;, we run:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x08049050&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pdf&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@main&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/pdf-main-command.png&quot; alt=&quot;pdf main&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The same way, we can print the content of &lt;em&gt;sym.mul&lt;/em&gt; and &lt;em&gt;sym.sum&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/pdf-fun-command.png&quot; alt=&quot;pdf fun&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;getting-help-the--command&quot;&gt;Getting help.! The ? command&lt;/h2&gt;

&lt;p&gt;If I want you to remember something about this post is this: when in doubt, use the &lt;strong&gt;&lt;em&gt;-? command-&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x08049050&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;It diplays help for r2 commands. But it goes further, you will see that there are commands composed of more than one character, such as pdf, and talking about pdf, we saw that pd does print disassembly and pdf does it as well but of a function. Those two commands belong to the print disassembly commands.&lt;/p&gt;

&lt;p&gt;Like pd and pdf, there are other commands that kind of belong to a “category” of commands, like debugging commands, register commands, print mode commands and so on. And all of them look similar within their categories.&lt;/p&gt;

&lt;p&gt;Let’s say you want more info about print disassembly commands, you can get such information by running:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x08049050&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;img src=&quot;/assets/radare2-basic-wf/pd-help-command.png&quot; alt=&quot;pd ?&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Following that logic, you can get help not only on a specific command, but about a “category” of commands.&lt;/p&gt;

&lt;p&gt;There are a lot of other commands within the command mode. We are going to go through some of them but they happen to be more useful when they are used in visual mode so, we are going to see them &lt;strong&gt;in the second part&lt;/strong&gt; of this posts.&lt;/p&gt;

&lt;p&gt;Anyway, with the information at this point, you should be able to play around with commands, getting help about them and experiment to see what they do.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://radare.gitbooks.io/radare2book/content/&quot;&gt;Radare2 Official Book&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/rizinorg/cutter&quot;&gt;Cutter GitHub Repository&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/rizinorg/rizin&quot;&gt;Rizin GitHub Repository&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Rodo Gómez</name></author><summary type="html">This is the first post out of two that describes the usage of Radare2 to perform basic tasks that relate to binary analysis. That way, instead of explaining what a bunch of Radare commands do, this post goes through a basic workflow from opening a binary file, gather basic information about it, dissasemble it, explaining and working with the different modes that Radare2 offers and explore the disassembled binary.</summary></entry></feed>